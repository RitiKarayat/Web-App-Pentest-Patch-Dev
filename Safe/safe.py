#!/usr/bin/env python3

from flask import Flask, render_template, request, redirect, make_response, session
from flask import send_file,send_from_directory
import sqlite3
import os
import zipfile
import hashlib
import subprocess

from matplotlib.cbook import index_of
db = "storage.db"

app = Flask(__name__)

# Convince browsers like Chrome to allow easy non-persistent XSS


# @app.after_request
# def no_XSS_Protection(response):
#     response.headers["X-XSS-Protection"] = '0'
#     return response

@app.after_request
def XSS_protection(response):
    response.headers['Content-Security-Policy'] = "default-src 'self'"
    return response

def hash(data):
    """ Wrapper around sha224 """
    return hashlib.sha224(data.replace('\n', '').encode('ascii')).hexdigest()


@app.route('/')
def main():
    if not 'username' in session:
        return redirect("/login", 303)
    ul = None
    return render_template('main.html', name=session['username'][0], users=ul, news=getNews())


@app.route('/login', methods=['GET', 'POST'])
def login():
    if request.method == 'GET':
        return render_template('form.html')
    elif request.method == 'POST':
        conn = sqlite3.connect('storage.db')
        c = conn.cursor()
        email = request.form['email']
        password = hash(request.form['password'])
        print("SELECT * FROM users WHERE email='%s' AND password='%s'" %
              (email, password))
        c.execute("SELECT * FROM users WHERE email= ? AND password= ?" ,
                  (email, password))
        #c.execute("SELECT * FROM users WHERE email='%s' AND password='%s'" %
                  #(email, password))
        rval = c.fetchone()
        if email == 'admin@a.com' and password == app.adminhash:
            rval = ('admin', 'admin', 'admin')
        if rval:
            session['username'] = rval
            return redirect("/", 303)
        else:
            return render_template('form.html', error='Username or password incorrect!')


@app.route('/logout')
def logout():
    session.pop('username', None)
    return redirect("/login", 303)


@app.route('/search')
def search():
    if not 'username' in session:
        return redirect("/login", 303)
    term = request.args.get('term')
    return render_template('main.html', name=session['username'][0], error="Search not implemented yet. Could not find " + term, news=getNews())


def getNews():
    conn = sqlite3.connect('storage.db')
    c = conn.cursor()
    return c.execute("SELECT * FROM news").fetchall()


@app.route('/news')
def news():
    if not 'username' in session:
        return redirect("/login", 303)
    term = request.args.get('text')
    conn = sqlite3.connect('storage.db')
    c = conn.cursor()
    print(term)
    c.execute("insert into news (source,text) values (?,?)",
              (session['username'][0], term))
    conn.commit()
    return render_template('main.html', name=session['username'][0], news=getNews())

import shlex
@app.route('/ping', methods=['POST'])
def ping():
    var = request.form['target']
    #print(type(var))
    operators = ['&','&&','||',';']
    for op in operators:
        if op in var:
            idx = var.index(op)
            var = var[0:idx]
    #print(var)
    cmd = 'ping -c 1 ' + var
    stream = subprocess.Popen(
        cmd, shell=True, executable='/bin/bash', stdout=subprocess.PIPE)
    rval = stream.stdout.read()
    print(rval)
    return render_template('main.html', name=session['username'][0], error3=rval, news=getNews())

@app.route('/download')
def download():
    #For windows you need to use drive name [ex: F:/Example.pdf]
    path = "/home/kali/Desktop/CEH/sf_test_1/index.html"
    return send_file(path, as_attachment=True)

@app.route('/download_files')
def download_all():
    # Zip file Initialization
    zipfolder = zipfile.ZipFile('reports.zip','w', compression = zipfile.ZIP_STORED) # Compression type 

    # zip all the files which are inside in the folder
    print(os.walk('/home/kali/Desktop/CEH/sf_test_2/'))
    for root,dirs, files in os.walk('/home/kali/Desktop/CEH/sf_test_2/'):
        for file in files:
            zipfolder.write('./sf_test_3/'+file)
    zipfolder.close()

    return send_file('reports.zip',
            mimetype = 'zip',
            attachment_filename= 'reports.zip',
            as_attachment = True)

    # Delete the zip file if not needed
    os.remove("report.zip")
from io import BytesIO
import time
@app.route('/zipped_data')
def zipped_data():
    timestr = time.strftime("%Y%m%d-%H%M%S")
    fileName = "my_data_dump_{}.zip".format(timestr)
    memory_file = BytesIO()
    file_path = './sf_test_3/'
    with zipfile.ZipFile(memory_file, 'w', zipfile.ZIP_DEFLATED) as zipf:
          for root, dirs, files in os.walk(file_path):
                    for file in files:
                              zipf.write(os.path.join(root, file))
    memory_file.seek(0)
    return send_file(memory_file,
                     attachment_filename=fileName,
                     as_attachment=True)


@app.route('/new')
def new():
    file_paths = []

 # crawling through directory and subdirectories
    for root, directories, files in os.walk('./sf_test_3/'):
        for filename in files:
            # join the two strings in order to form the full filepath.
            filepath = os.path.join(root, filename)
            file_paths.append(filepath)
    print('Following files will be zipped in this program:')
    for file_name in file_paths:
        print(file_name)

    with zipfile.ZipFile('newzipfile.zip','w') as zip:
        # writing each file one by one
        for file in file_paths:
            zip.write(file)

    print('All files zipped successfully!')
    return send_file('newzipfile.zip',
        mimetype = 'zip',
        attachment_filename= 'newreports.zip',
        as_attachment = True)
if __name__ == '__main__':

    with open('secrets', 'r') as f:
        s = f.readlines()
    app.secret_key = s[0].replace('\n', '')
    app.adminhash = hash(s[1])
    alicehash = hash(s[2])

    try:
        os.remove(db)
    except OSError:
        pass
    conn = sqlite3.connect(db)
    c = conn.cursor()
    c.execute("create table if not exists news(source string, text string)")
    c.execute(
        "create table if not exists users(name string, password string, email string) ")
    c.execute(
        "insert into users (email, name,password) values ('ritik@ymail.com','ritik','" + alicehash + "')")
    conn.commit()
    app.config.update(SESSION_COOKIE_HTTPONLY=False)
    app.run(debug=True,port=9999)

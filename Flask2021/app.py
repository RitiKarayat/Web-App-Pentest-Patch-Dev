from crypt import methods
import smtplib
from enum import unique
import imp
from pickle import GET, TRUE
import bcrypt
from flask import Flask, render_template, url_for, redirect,session
from flask_sqlalchemy import SQLAlchemy
import sqlalchemy
from flask_login import UserMixin, login_user,LoginManager, login_required, logout_user, current_user
from flask_wtf import FlaskForm
from wtforms import StringField,PasswordField,SubmitField
from wtforms.validators import InputRequired, Length, ValidationError
from flask_bcrypt import Bcrypt
from urllib.parse import urljoin
import numpy as np
from flask import Flask, request, jsonify, render_template
import pickle
import pandas as pd
import requests
from pprint import pprint
from bs4 import BeautifulSoup
from bs4 import BeautifulSoup as bs
import colorama
from urllib.parse import urljoin,urlparse
import time
from io import BytesIO
from flask import send_file,send_from_directory
import zipfile
import os
import random
import subprocess
from selenium import webdriver
from webdriver_manager.chrome import ChromeDriverManager
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import UnexpectedAlertPresentException


total_urls_visited = 0
app = Flask(__name__)
bcrypt = Bcrypt(app)
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///database.db'
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
db = SQLAlchemy(app)
app.config['SECRET_KEY'] = 'thisisasecretkey'

login_manager = LoginManager()
login_manager.init_app(app)
login_manager.login_view = "login"


@login_manager.user_loader
def load_user(user_id):
    return User.query.get(int(user_id))


class User(db.Model, UserMixin):
    id = db.Column(db.Integer, primary_key=True)
    firstname = db.Column(db.String(100), nullable=False)
    lastname = db.Column(db.String(100), nullable=False)
    emailid = db.Column(db.String(100), unique=True)
    password = db.Column(db.String(100), nullable=False)


class RegisterForm(FlaskForm):
    firstname = StringField(validators=[InputRequired(), Length(
        min=4, max=20)], render_kw={"placeholder": "firstname"})
    lastname = StringField(validators=[InputRequired(), Length(
        min=4, max=20)], render_kw={"placeholder": "lastname"})
    emailid = StringField(validators=[InputRequired(), Length(
        min=4, max=20)], render_kw={"placeholder": "emailid"})
    password = PasswordField(validators=[InputRequired(), Length(
        min=4, max=20)], render_kw={"placeholder": "password"})
    submit = SubmitField("Register")

    def validate_username(self, emailid):
        existing_user_emailid = User.query.filterby(
            emailid=emailid.data).first()
        if existing_user_emailid:
            raise ValidationError(
                "This emailid already exists please choose a different one or login with this id"
            )


class LoginForm(FlaskForm):
    emailid = StringField(validators=[InputRequired(), Length(
        min=4, max=20)], render_kw={"placeholder": "emailid"})
    password = PasswordField(validators=[InputRequired(), Length(
        min=4, max=20)], render_kw={"placeholder": "Password"})
    submit = SubmitField("Login")


class ContactForm(FlaskForm):
    name = StringField(validators=[InputRequired(),Length(min=4, max=50)], render_kw={"placeholder": "Name"})
    emid = StringField(validators=[InputRequired(),Length(min=4, max=50)], render_kw={"placeholder": "EmailId"})
    subject = StringField(validators=[InputRequired(),Length(min=4, max=35)], render_kw={"placeholder": "Subject"})
    message = StringField(validators=[InputRequired(),Length(min=4, max=100)], render_kw={"placeholder": "Post your message"})


@app.route("/contact", methods=['GET', 'POST'])
def contact():
    form = ContactForm()
    if form.validate_on_submit():
        s = smtplib.SMTP('smtp.gmail.com', 587)
        # start TLS for security
        s.starttls()
        # Authentication
        s.login("housepred5@gmail.com", "Manish4@")
        # message = f"This email is regarding the contact request from {form.name.data} regarding the subject {form.subject.data}. This contact was initiated from the email {form.emid.data} and their message can be found here: {form.message.data}. Please initiate the contact with the user accordingly."
        message = f'''This email is regarding the contact request from {form.name.data} about the subject {form.subject.data}.
This email has been reveived from the id {form.emid.data} and the message can be found here: {form.message.data}.
Please initiate contact accordingly'''
        s.sendmail("housepred5@gmail.com", "housepred5@gmail.com", message)
        print(message)
        s.quit()

        r = smtplib.SMTP('smtp.gmail.com', 587)
        r.starttls()

        r.login("housepred5@gmail.com", "Manish4@")
        replymessage = f"Hi {form.name.data}, we have received your message from the email {form.emid.data} about the subject {form.subject.data}. Our agents will initiate contact with you as soon as possible to figure out the in-depth requirements of the consignment through the email-id mentioned earlier. "
        r.sendmail("housepred5@gmail.com", form.emid.data, replymessage)
        r.quit()
        # terminating the session

        return redirect(url_for("login"))
    return render_template("contact.html", form=form)


@app.route("/")
def hello_world():
    return render_template('index.html')


@app.route("/new", methods=['GET', 'POST'])
@login_required
def new():
    return render_template('new.html')


@app.route("/logout", methods=['GET', 'POST'])
@login_required
def logout():
    logout_user
    return redirect(url_for('login'))


@app.route("/login", methods=['GET', 'POST'])
def login():
    form = LoginForm()
    if form.validate_on_submit():
        user = User.query.filter_by(emailid=form.emailid.data).first()
        if user:
            if bcrypt.check_password_hash(user.password, form.password.data):
                login_user(user)
                return redirect(url_for('new'))
    return render_template('login.html', form=form)


@app.route("/register", methods=['GET', 'POST'])
def register():
    form = RegisterForm()
    print(form)

    if form.validate_on_submit():
        hashed_password = bcrypt.generate_password_hash(form.password.data)
        new_user = User(firstname=form.firstname.data, lastname=form.lastname.data, emailid=form.emailid.data,
                        password=hashed_password)
        db.session.add(new_user)
        db.session.commit()
        return redirect(url_for('login'))

    return render_template('register.html', form=form)


@app.route("/spider")
def spider():
    return render_template('spider.html')



@app.route('/c_d', methods=['POST'])
def c_d():
    GREEN = colorama.Fore.WHITE
    GRAY = colorama.Fore.WHITE
    RESET = colorama.Fore.RESET
    YELLOW = colorama.Fore.WHITE
    internal_urls = set()
    external_urls = set()

    internal = []
    external = []

    def is_valid(url):
        parsed = urlparse(url)
        return bool(parsed.netloc) and bool(parsed.scheme)

    def get_all_website_links(url):
        urls = set()

        domain_name = urlparse(url).netloc
        soup = BeautifulSoup(requests.get(url).content, "html.parser")
        for a_tag in soup.findAll("a"):
            href = a_tag.attrs.get("href")
            if href == "" or href is None:
                continue

            href = urljoin(url, href)
            parsed_href = urlparse(href)

            href = parsed_href.scheme + "://" + parsed_href.netloc + parsed_href.path
            if not is_valid(href):
                continue
            if href in internal_urls:
                continue
            if domain_name not in href:

                if href not in external_urls:
                    # print(f"{GRAY}[!] External link: {href}{RESET}")
                    internal.append(f"{href}{RESET}"[0:-5])
                    external_urls.add(href)
                continue
            # print(f"{GREEN}[*] Internal link: {href}{RESET}")
            external.append(f"{href}{RESET}"[0:-5])
            urls.add(href)
            internal_urls.add(href)
        return urls

    def crawl(url, max_urls=30):
        global total_urls_visited
        total_urls_visited += 1
        links = get_all_website_links(url)
        for link in links:
            if total_urls_visited > max_urls:
                break
            crawl(link, max_urls)

    url = request.form['c_d']
    crawl(url)
    internal_sen = []
    for website in internal:
        if website[0] == "h":
            internal_sen.append(website)
    external_sen = []
    for website in external:
        if website[0] == "h":
            external_sen.append(website)
    sen = internal_sen + external_sen
    # print(external)
    print("[+] Total Internal links:", len(internal_urls))
    print("[+] Total External links:", len(external_urls))
    print(internal_sen)
    print(external_sen)
    reals = "compleated"

    return render_template("spider.html", real=reals, external_link=external_sen, internal_link=internal_sen,
                           len_i=len(internal_urls), len_e=len(external_urls))








@app.route("/SqlScanner")
def SqlScanner():
    return render_template('SqlScanner.html')



@app.route('/predict_sqli',methods = ['POST'])

def predict_sqli():
    s = requests.Session()
    s.headers["User-Agent"] = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.106 Safari/537.36"

    def get_all_forms(url):
        """Given a `url`, it returns all forms from the HTML content"""
        soup = bs(s.get(url).content, "html.parser")
        return soup.find_all("form")


    def get_form_details(form):
        """
        This function extracts all possible useful information about an HTML `form`
        """
        details = {}
        try:
            action = form.attrs.get("action").lower()
        except:
            action = None
        method = form.attrs.get("method", "get").lower()
        inputs = []
        for input_tag in form.find_all("input"):
            input_type = input_tag.attrs.get("type", "text")
            input_name = input_tag.attrs.get("name")
            input_value = input_tag.attrs.get("value", "")
            inputs.append({"type": input_type, "name": input_name, "value": input_value})
        # put everything to the resulting dictionary
        details["action"] = action
        details["method"] = method
        details["inputs"] = inputs
        return details


    def is_vulnerable(response):
        """A simple boolean function that determines whether a page
        is SQL Injection vulnerable from its `response`"""
        errors = {
            # MySQL
            "you have an error in your sql syntax;",
            "warning: mysql",
            # SQL Server
            "unclosed quotation mark after the character string",
            # Oracle
            "quoted string not properly terminated",
        }
        for error in errors:
            if error in response.content.decode().lower():
                return True
        return False


    def scan_sql_injection(url):
        for c in "\"'":
            new_url = f"{url}{c}"
            print("[!] Trying", new_url)
            res = s.get(new_url)
            if is_vulnerable(res):
                print("[+] SQL Injection vulnerability detected, link:", new_url)
                list_vul.append(1)
                return
        forms = get_all_forms(url)
        print(f"[+] Detected {len(forms)} forms on {url}.")
        for form in forms:
            form_details = get_form_details(form)
            for c in "\"'":
                data = {}
                for input_tag in form_details["inputs"]:
                    if input_tag["value"] or input_tag["type"] == "hidden":
                        try:
                            data[input_tag["name"]] = input_tag["value"] + c
                        except:
                            pass
                    elif input_tag["type"] != "submit":
                        data[input_tag["name"]] = f"test{c}"
                url = urljoin(url, form_details["action"])
                if form_details["method"] == "post":
                    res = s.post(url, data=data)
                elif form_details["method"] == "get":
                    res = s.get(url, params=data)
                if is_vulnerable(res):
                    print("[+] SQL Injection vulnerability detected, link:", url)
                    print("[+] Form:")
                    list_vul.append(1)
                    pprint(form_details)
                    break


    list_vul=[]
    url=request.form['Url_Sqli']
    gg=scan_sql_injection(url)


    if len(list_vul)==0:
        sentense="Site is not Vernurable"
        return render_template("SqlScanner.html",prediction_text=sentense)
    else:
        sen1="gg"
        sentense="Site is Vernurable"
        return render_template("SqlScanner.html",prediction_text=sentense)







@app.route("/XssScanner")
def XssScanner():
    return render_template('XssScanner.html')


@app.route('/predict_xss', methods=['POST'])
def predict_xss():
    def scan_xss(url):
        forms = get_all_forms(url)
        list_length.append(len(forms))
        js_script = "<Script>alert('hi')</scripT>"
        is_vulnerable = False
        for form in forms:
            form_details = get_form_details(form)
            list_form.append(form_details)
            content = submit_form(form_details, url, js_script).content.decode()
            if js_script in content:
                pprint(form_details)
                is_vulnerable = True
                list_vur.append(is_vulnerable)
        return is_vulnerable

    def get_all_forms(url):
        soup = bs(requests.get(url).content, "html.parser")
        return soup.find_all("form")

    def get_form_details(form):
        details = {}
        action = form.attrs.get("action").lower()
        method = form.attrs.get("method", "get").lower()
        inputs = []
        for input_tag in form.find_all("input"):
            input_type = input_tag.attrs.get("type", "text")
            input_name = input_tag.attrs.get("name")
            inputs.append({"type": input_type, "name": input_name})
        details["action"] = action
        details["method"] = method
        details["inputs"] = inputs
        return details

    def submit_form(form_details, url, value):
        target_url = urljoin(url, form_details["action"])
        target.append(target_url)
        inputs = form_details["inputs"]
        data = {}
        for input in inputs:
            if input["type"] == "text" or input["type"] == "search":
                input["value"] = value
            input_name = input.get("name")
            input_value = input.get("value")
            if input_name and input_value:
                data[input_name] = input_value

        if form_details["method"] == "post":
            return requests.post(target_url, data=data)
        else:
            return requests.get(target_url, params=data)

    list_form = []
    list_length = []
    list_vur = []
    target = []
    url = request.form['Url_Xss']

    gg = scan_xss(url)

    print(list_form)
    print(list_length)
    print(list_vur)
    payload_list = ["<img src=1 onerror=alert('1')>", "<script>alert('hi')</script>"]

    if len(list_vur) == 0:
        sentense = "Site is not Vernurable"
        return render_template("XssScanner.html", url=target[0], numberf=str(len(list_length)),
                               methodf=list_form[0]['method'], payload=payload_list, result=sentense)
    else:
        if list_form[0]['method'] == "get":
            search = str(list_form[0]['inputs'][0]['name'])
            print(target)
            final_url = str(target[0]) + "?" + search + "=<img src=1 onerror=alert('1')>"
            browser = webdriver.Chrome(ChromeDriverManager().install())
            browser.get(final_url)
            try:
                browser.find_element_by_name("submit")
                WebDriverWait(browser, 3).until(EC.alert_is_present(),
                                                'Timed out waiting for PA creation ' +
                                                'confirmation popup to appear.')
                alert = browser.switch_to.alert
                alert.accept()
                alert.dismiss()
                print("alert accepted")
            except UnexpectedAlertPresentException:
                print("alert is there")
            sen1 = "gg"
            sentense = "Site is Vernurable"
            return render_template("XssScanner.html", url=target[0], numberf=str(len(list_length)),
                                   methodf=list_form[0]['method'], payload=payload_list, result=sentense)
        else:
            sen1 = "gg"
            sentense = "Site is Vernurable"
            return render_template("XssScanner.html", url=target[0], numberf=str(len(list_length)),
                                   methodf=list_form[0]['method'], payload=payload_list, result=sentense)


@app.route('/skipfish',methods=['GET'])
def skipfish():
    return render_template('skipfish.html')

import shlex
@app.route('/skipfish_scan',methods = ['POST'])

def skipfish_scan():
    
    def skipfish(url,time):
        global num
        num = random.randint(1,100)
        cmd = f'skipfish -k {time} -o ./sf_test_{num} {url}'
        print('started')
        print(cmd)
        #cmd = './while.sh'
        stream = subprocess.run(cmd, shell=True, executable='/bin/bash', stdout=subprocess.PIPE , input='enter\n', text=True)#, stderr=subprocess.PIPE, stdin=subprocess.PIPE , text=True  , check=True)
        #print(stream.stdout.decode())

        # stream.stdin.write('Enter')
        # #stream.stdin.write('Press')
        # stream.stdin.close()
        print('done')
    timer = request.form['time']   
    url = request.form['url']
    skipfish(url,timer)
    return render_template("skipfish.html",prediction_text='Scan Completed')


@app.route('/zipped_data',methods = ['GET','POST'])
def zipped_data():
    timestr = time.strftime("%Y%m%d-%H%M%S")
    fileName = f"Skipfish_Report_{num}.zip"
    memory_file = BytesIO()
    file_path = f'./sf_test_{num}/'
    with zipfile.ZipFile(memory_file, 'w', zipfile.ZIP_DEFLATED) as zipf:
          for root, dirs, files in os.walk(file_path):
                    for file in files:
                              zipf.write(os.path.join(root, file))
    memory_file.seek(0)
    return send_file(memory_file,
                     attachment_filename=fileName,
                     as_attachment=True)











if __name__ == "__main__":
    app.run(debug=True, port=3000)